using Pkg
using Plots
using ViscousStreaming
using NBInclude
using HDF5
using JLD2
using LinearAlgebra

strdVuxy = load("strdVuxy_quad.jld2")["data"];
strdVvxy = load("strdVvxy_quad.jld2")["data"];

Re = 40
 ϵ = 0.1
 Ω = 1.0 # frequency (keep this equal to 1)
 Tp = 2π/Ω # one period of oscillation
 p = StreamingParams(ϵ,Re)
 #s = StreamingAnalytical(p)

 τ = 0.1 # Stokes number, should be small
 β = 0.95 # Density parameter. Less than 1 means heavier than fluid.
 p_inert = InertialParameters(tau=τ,beta=β,epsilon=ϵ,Re=Re)
 Ω = 1.0
 Tp = 2π/Ω
 Tmax = 50*Tp

 Δx = 0.02
 xlim = (-2.8,2.8)
 ylim = (-2.8,2.8)
 n = 75
 body = Circle(0.2,n)

 bl = BodyList()
 bL1 = deepcopy(body)
 bL2 = deepcopy(body)
 bR1 = deepcopy(body)
 bR2 = deepcopy(body)

#Quadrilateral
# left 1 cylinder
cent = (-2.0,1.3)
 α = 0.0
TL1 = RigidTransform(cent,α)
TL1(bL1) # transform the body to the current configuration

# left 2 cylinder
cent = (-2.3,-1.0)
 α = 0.0
TL2 = RigidTransform(cent,α)
TL2(bL2) # transform the body to the current configuration

# right 1 cylinder
cent = (1.5,2.2)
 α = 0.0
TR1 = RigidTransform(cent,α)
TR1(bR1) # transform the body to the current configuration

# right 2 cylinder
cent = (0.1,-2.5)
 α = 0.0
TR2 = RigidTransform(cent,α)
TR2(bR2) # transform the body to the current configuration

push!(bl,bL1);
push!(bl,bL2);
push!(bl,bR1);
push!(bl,bR2);

ampvec = [ComplexF64[0.0,0.0] for i in 1:length(bl)]; a1 = deepcopy(ampvec); 
ampvec[1] = [1,0]; a2 = deepcopy(ampvec);
ampvec[2] = [1,0]; a3 = deepcopy(ampvec); 
ampvec[3] = [1,0]; a4 = deepcopy(ampvec); 
ampvec[4] = [1,0]; a5 = deepcopy(ampvec);
ampvec[1] = [0,0]; a6 = deepcopy(ampvec);
ampvec[2] = [0,0]; a7 = deepcopy(ampvec);
ampvec[3] = [0,0]; a8 = deepcopy(ampvec);
ampvec[2] = [1,0]; a9 = deepcopy(ampvec);
ampvec[1] = [1,0]; a10 = deepcopy(ampvec);
ampvec[2] = [0,0]; a11 = deepcopy(ampvec);
ampvec[3] = [1,0]; a12 = deepcopy(ampvec);
ampvec[4] = [0,0]; a13 = deepcopy(ampvec);
ampvec[1] = [0,0]; a14 = deepcopy(ampvec);
ampvec[2] = [1,0]; a15 = deepcopy(ampvec);
ampvec[3] = [0,0]; a16 = deepcopy(ampvec);

actionspace = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16];

xy_states = hcat(range(-1.8,stop = 1.8,length = 73), range(-1.8,stop = 1.8,length = 73));

function mean_motion(dR,R,p,t,v̄Luxy,v̄Lvxy)
    dR[1] = v̄Luxy(R[1],R[2])
    dR[2] = v̄Lvxy(R[1],R[2])
    return dR 
end

function getstate(state)
    posx, posy = state
    oparx = zeros(length(xy_states[:,1])); opary = zeros(length(xy_states[:,2]));
    if length(xy_states[:,1]) == length(xy_states[:,2])
        for i = 1:length(xy_states[:,1])
            oparx[i] = abs(posx - xy_states[i,1]) 
            opary[i] = abs(posy - xy_states[i,2])
        end
    else
        for i = 1:length(xy_states[:,1])
            oparx[i] = abs(posx - xy_states[i,1]) 
        end
        for i = 1:length(xy_states[:,2])
            opary[i] = abs(posy - xy_states[i,2])
        end
    end
    return argmin(oparx), argmin(opary)
end

function randomaction()
    lo = rand(1:length(actionspace)) 
    return actionspace[lo], lo
end

function reset_state()
    return xy_states[rand(1:length(xy_states[:,1])),1], xy_states[rand(1:length(xy_states[:,1])),2]
end

function motion(curstate, ampvel_ind)
    newposx = 0
    newposy = 0
    done = false
    marker = true
    if ampvel_ind == 1
        newposx, newposy = curstate
    else
        v̄Lfcn(dR,R,p,t) = mean_motion(dR,R,p,t,strdVuxy[ampvel_ind-1],strdVvxy[ampvel_ind-1])
        solL = compute_trajectory(v̄Lfcn,curstate,Tmax,10Tp,bl=bl,ϵ=p.ϵ);
        newposx = last(solL[1,:])
        newposy = last(solL[2,:])
    end  
    indnx, indny = getstate((newposx,newposy)) 
    if newposx < xy_states[1,1] || newposx > xy_states[end,1] || newposy < xy_states[1,2] || newposy > xy_states[end,2]
        reward = -50
        newposx, newposy = curstate
        marker = false
    elseif (indnx == 37) && (indny == 37)
        reward = 100
        done = true
    else
        reward = 0
    end  
    return (newposx, newposy), reward, done #, marker
end

function q_table()
    stateforq = Vector(undef,(length(xy_states[:,1])*length(xy_states[:,2])))
    k = 0
    for i in 1:length(xy_states[:,1])
        for j in 1:length(xy_states[:,2])
            val = (i,j)
            k += 1
            stateforq[k] = val
        end
    end
    Q = Dict()
    for i in  stateforq
        for j in  actionspace
            Q[i,j] = 0 #rand(1:16)     #0 #(Int(rand(Int8)))^2
        end
    end
    return Q
end

function maxval(Q, state, action)
    qval = [Q[state,a] for a in action]
    actind = argmax(qval)
    return action[actind],actind
end

function symmetricstate_y(state)
    return (-state[1],state[2]) 
end

function symmetricstate_x(state)
    return (state[1],-state[2]) 
end

function symmetricstate_xy(state)
    return (-state[1],-state[2]) 
end

function actsym(actin, label)
    @assert label ∈ ("ysym","xsym","xysym")
    if label == "ysym"
        for i in 1:length(actionsymy)
            if actin == actionsymy[i][1]
                return actionsymy[i][2]
            elseif actin == actionsymy[i][2]
                return actionsymy[i][1]
            end
        end
    elseif label == "xsym"
        for i in 1:length(actionsymx)
            if actin == actionsymx[i][1]
                return actionsymx[i][2]
            elseif actin == actionsymx[i][2]
                return actionsymx[i][1]
            end
        end
    elseif label == "xysym"
        for i in 1:length(actionsymxy)
            if actin == actionsymxy[i][1]
                return actionsymxy[i][2]
            elseif actin == actionsymxy[i][2]
                return actionsymxy[i][1]
            end
        end
    end
end


function check_motion(curstate, ampvel_ind)
    if ampvel_ind == 1
        return (curstate)
    else       
        v̄Lfcn(dR,R,p,t) = mean_motion(dR,R,p,t,strdVuxy[ampvel_ind-1],strdVvxy[ampvel_ind-1])
        solL = compute_trajectory(v̄Lfcn,curstate,Tmax,10Tp,bl=bl,ϵ=p.ϵ);
        return (last(solL[1,:]),last(solL[2,:]))
    end
end

function symmetryaction(state, label)
    r = []
    @assert label ∈ ("ysym","xsym","xysym")
    if label == "ysym"
        sym_state = symmetricstate_y(state)
        for i in 1:length(actionspace)
            for j in 1:i
                newpos = check_motion(state,i)
                newpos_sym = check_motion(sym_state,j)
                if (getstate(newpos) == getstate(symmetricstate_y(newpos_sym)))
                    push!(r,(i,j))
                end
            end
        end
        return r
    elseif label == "xsym"
        sym_state = symmetricstate_x(state)
        for i in 1:length(actionspace)
            for j in 1:i
                newpos = check_motion(state,i)
                newpos_sym = check_motion(sym_state,j)
                if (getstate(newpos) == getstate(symmetricstate_x(newpos_sym)))
                    push!(r,(i,j))
                end        
            end
        end
        return r      
    elseif label == "xysym"
        sym_state = symmetricstate_xy(state)
        for i in 1:length(actionspace)
            for j in 1:i
                newpos = check_motion(state,i)
                newpos_sym = check_motion(sym_state,j)
                if (getstate(newpos) == getstate(symmetricstate_xy(newpos_sym)))
                    push!(r,(i,j))
                end
            end
        end
        return r
    end
end

function score_check(Q)
    score = []                
    for action_steps in 5:5:25
        track = 0
        for x_pos in xy_states[:,1]
            for y_pos in xy_states[:,2]
                currstate = (x_pos,y_pos)
                for n in 1:action_steps
                    curr_indexst = getstate(currstate)
                    curraction, curraction_index = maxval(Q,curr_indexst,actionspace)
                    currstate = check_motion(currstate, curraction_index)
                end
                if getstate(currstate) == (37,37)
                    track += 1
                end
            end
        end
        push!(score,(track/(length(xy_states[:,1])*length(xy_states[:,2])))*100)
    end 
    return score
end

function symmetry_detect(Q,label)
    @assert label ∈ ("ysym","xsym","xysym")
    symness_check = zeros(length(xy_states[:,1]),length(xy_states[:,2]))
    if label == "ysym"
        for i = 1:length(xy_states[:,1])
            for j = 1:length(xy_states[:,2])   
                """                
                if argmax([Q[(i,j),a] for a in actionspace]) - 
                        actsym(argmax([Q[(getstate(symmetricstate_y((xy_states[i,1],xy_states[j,2])))),a] 
                                for a in actionspace]), label) == 0 && maximum([Q[(i,j),a] for a in actionspace]) != 0
                    symness_check[i,j] = 1
                else
                    symness_check[i,j] = 0
                end
                """
                max_action_ind = argmax([Q[(i,j),a] for a in actionspace])
                if max_action_ind - actsym(argmax([Q[(getstate(symmetricstate_y((xy_states[i,1],xy_states[j,2])))),a] 
                        for a in actionspace]), label) == 0 && Q[(i,j),actionspace[max_action_ind]] != 0
                    symness_check[i,j] = 1
                else
                    symness_check[i,j] = 0
                end
                
                
            end
        end
    elseif label == "xsym"
        for i = 1:length(xy_states[:,1])
            for j = 1:length(xy_states[:,2])  
                """
                if argmax([Q[(i,j),a] for a in actionspace]) - 
                        actsym(argmax([Q[(getstate(symmetricstate_x((xy_states[i,1],xy_states[j,2])))),a] 
                                for a in actionspace]), label) == 0
                    symness_check[i,j] = 1
                else
                    symness_check[i,j] = 0
                end
                """
                max_action_ind = argmax([Q[(i,j),a] for a in actionspace])
                if max_action_ind - actsym(argmax([Q[(getstate(symmetricstate_x((xy_states[i,1],xy_states[j,2])))),a] 
                        for a in actionspace]), label) == 0 && Q[(i,j),actionspace[max_action_ind]] != 0
                    symness_check[i,j] = 1
                else
                    symness_check[i,j] = 0
                end
                
            end
        end
        
    elseif label == "xysym"
              
    end
    return norm(symness_check)/norm(ones(length(xy_states[:,1]),length(xy_states[:,2])))
end

actionsymx = symmetryaction(reset_state(),"xsym")

actionsymy = symmetryaction(reset_state(),"ysym")

actionsymy = [(1, 1)
 (5, 5)
 (7, 3)
 (9, 9)
 (10, 6)
 (12, 4)
 (13, 13)
 (14, 2)
 (15, 11)
 (16, 8)]

actionsymx = [ (1, 1)
 (3, 3)
 (5, 5)
 (7, 7)
 (10, 4)
 (12, 6)
 (13, 9)
 (14, 8)
 (15, 11)
 (16, 2)]

actionsymxy = symmetryaction(reset_state(),"xysym")

function main_sym_detect()

        alpha = 0.4
        gamma = 0.9
        iter = 300        
        Q = q_table()
        episodes = 30000
        totalr = []
        score_cumulative = []
        x_symness = []
        y_symness = []
        #push!(y_symness,0)
        for i in 1:episodes
            epsilon = 1.0
            if i%1000 == 1
                println("Printing episode no: ", i)
            end    
            done = false
            epr = 0
            currentstate = reset_state()
            for j in 1:iter
                indexst = getstate(currentstate)       
                epste = rand()          
                if epste>epsilon
                     currentaction, currentaction_index = maxval(Q,indexst,actionspace)
                else
                     currentaction, currentaction_index = randomaction()
                end       
                cnewstate, creward, done = motion(currentstate, currentaction_index)
                epr = epr + creward
                cnindexst = getstate(cnewstate)
                factionval, factionind = maxval(Q,cnindexst,actionspace) 
                #if (marker)
                Q[indexst, currentaction] = Q[indexst, currentaction] + 
                                            alpha*(creward + gamma*Q[cnindexst,factionval] - Q[indexst, currentaction])
                
                """
                if (y_symness[end] > 0.45)
                    sym_currentactiony_index = actsym(currentaction_index,"ysym")
                    sym_indexsty = getstate(symmetricstate_y(currentstate))  
                    Q[sym_indexsty, actionspace[sym_currentactiony_index]] = deepcopy(Q[indexst, currentaction])
                end
                """
            
                currentstate = cnewstate 
                #end
                if epsilon > 0.1
                    epsilon = epsilon*0.985
                end 
            end
            push!(totalr,epr)
            if i%1000 == 1
                println(totalr[i])
            end
            
            if i%100 == 0
                push!(y_symness, symmetry_detect(Q, "ysym"))
                push!(x_symness, symmetry_detect(Q, "xsym"))
                push!(score_cumulative,score_check(Q))
            end
            
        end
return Q, totalr, y_symness, x_symness, score_cumulative
end

@time Q_symdetect_quad, reward_symdetect_quad, y_symness_quad, x_symness_quad, score_symdetect_quad = main_sym_detect()

@gif for k = 1:300
    plot([k for k = 5:5:25],score_symdetect_quad[k],legend=:bottomright,xlim=(5,25), ylim=(0, 100),title = string("Policy Comparison at Episode ",(k*100)),label = ["Quadrilateral"])
    xlabel!("Number of Steps")     
    ylabel!("Percentage Success")
end

@gif for k = 1:300
    plot([k for k = 5:5:25],score_symdetect_quad[k],legend=:bottomright,xlim=(5,25), ylim=(0, 100),title = string("Policy Comparison at Episode ",(k*100)),label = ["Quadrilateral"])
    xlabel!("Number of Steps")     
    ylabel!("Percentage Success")
end

@gif for k = 1:300
    plot([k for k = 5:5:25],score_symdetect_quad[k],legend=:bottomright,xlim=(5,25), ylim=(0, 100),title = string("Policy Comparison at Episode ",(k*100)),label = ["Quadrilateral"])
    xlabel!("Number of Steps")     
    ylabel!("Percentage Success")
end

ps = plot(reward_symdetect_quad, xlim = (1, 30000), label = "")
ps = xlabel!(ps,"Number of Episodes")     
ps = ylabel!(ps,"Reward")

savefig(ps,"reward_qlearn_apara.png")

ps = plot(y_symness_quad,xlim=(0,300),ylim=(0,1), label = "")
ps = xlabel!("Point of Symmetry Check (x100)")     
ps = ylabel!("Y Symmetry Score")

savefig(ps,"ysymscore_apara.png")

plot([k for k = 0:100:29900],y_symness_quad, xlim=(0,31000), ylim=(0,1),legend=:topright, label = ["Y axis"],title = string("Symmetry Scores for Aparallelogram"))
plot!([k for k = 0:100:29900],x_symness_quad, label = ["X axis"])
xlabel!("Number of Episodes")     
ylabel!("Symmetry Score")

ps = plot(x_symness_quad,xlim=(0,300),ylim=(0,1),label="")
ps = xlabel!("Point of Symmetry Check (x100)")     
ps = ylabel!("X Symmetry Score")

savefig(ps,"xsymscore_apara.png")

lt_xsym = zeros(73,73)
for i = 1:73
    for j = 1:73
        qval_state = [Q_ysym_detect[(i,j),a] for a in actionspace]
        lt_xsym[i,j] = argmax(qval_state)
    end
end

heatmap([i for i = 1:1:73],[i for i = 1:1:73],lt_xsym)

symmetry_detect(Q_ysym_detect, "xsym")

function motion1(curstate, ampvel_ind)
    newposx = 0
    newposy = 0
    done = false
    
    if ampvel_ind == 1
        newposx, newposy = curstate
    else  
        v̄Lfcn(dR,R,p,t) = mean_motion(dR,R,p,t,strdVuxy[ampvel_ind-1],strdVvxy[ampvel_ind-1])
        global solL = compute_trajectory(v̄Lfcn,curstate,Tmax,10Tp,bl=bl,ϵ=p.ϵ);
        newposx = last(solL[1,:])
        newposy = last(solL[2,:])     
    end
    
    return (newposx,newposy), solL[1,:], solL[2,:]
end

@time solver2 = FrequencyStreaming(Re,ϵ,Δx,xlim,ylim,bl);

pos1 = []
pos2 = []
#pos3 = []
#pos4 = []
#pos5 = []
#pos6 = []
#pos7 = []
#pos8 = []

currentstate1 = (-1.5,1.5)

for i in 1:50
    solx = []
    soly = []
    append!(pos1,currentstate1[1])
    append!(pos2,currentstate1[2])
    indexst1 = getstate(currentstate1)
    currentaction1, currentaction_index1 = maxval(Q_symdetect_quad,indexst1,actionspace)
    cnewstate1, solx, soly = motion1(currentstate1, currentaction_index1)
    currentstate1 = cnewstate1
    for j in 1:length(solx)
        append!(pos1,solx[j])
        append!(pos2,soly[j])
    end
    
    println(currentstate1)

end


soln = solver2(a1, bl);
xg, yg = coordinates(soln.s1.W,solver2.grid)
plot(pos1, pos2, ratio=1,legend=false,linewidth=1,xlim=xlim,ylim=ylim)
plot!(pos3, pos4, ratio=1,legend=false,linewidth=1,xlim=xlim,ylim=ylim)
plot!(pos5, pos6, ratio=1,legend=false,linewidth=1,xlim=xlim,ylim=ylim)
plot!(pos7, pos8, ratio=1,legend=false,linewidth=1,xlim=xlim,ylim=ylim)
#plot!(xg,yg,vorticity(0,soln.s1),levels=range(-2,2,length=30),clim=(-2,2),xlim=xlim,ylim=ylim)
#plot!(bl)

png("C:\\Users\\apujari1\\Documents\\Untitled1")

plot(xg,yg,vorticity(0,soln.s1),levels=range(-2,2,length=30),clim=(-2,2),xlim=xlim,ylim=ylim)
plot!(bl)


png("C:\\Users\\apujari1\\Documents\\Untitled2")

soln = solver2(a2, bl);


ps = plot(solLx[1,:], solLx[2,:], ratio=1,legend=false,linewidth=2,xlim=xlim,ylim=ylim,
    label="Particle trajectory")
psy = plot!(solLy[1,:], solLy[2,:], ratio=1,legend=false,linewidth=2,xlim=xlim,ylim=ylim,
    label="Particle trajectory")
psz = plot!(solLz[1,:], solLz[2,:], ratio=1,legend=false,linewidth=2,xlim=xlim,ylim=ylim,
    label="Particle trajectory")
plot!(ps,lagrangian_mean_streamfunction(soln),soln.g,levels=15,color=:black,linewidth=0.5)
plot!(ps,bl,fillcolor=:gray,linecolor=:gray)
display(ps)

Tx = 15000 * Tp

v̄Lfcn(dR,R,p,t) = mean_motion(dR,R,p,t,strdVuxy[1],strdVvxy[1])
solLz = compute_trajectory(v̄Lfcn,(-1.7,-1),Tx,10Tp,bl=bl,ϵ=p.ϵ);



